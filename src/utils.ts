import BN from 'bn.js'
import assert from 'assert'
import nacl from 'tweetnacl'
import * as bip32 from 'bip32'
import {
  Account,
  Connection,
  Transaction,
  TransactionInstruction,
  PublicKey,
  SYSVAR_RENT_PUBKEY
} from '@solana/web3.js'
import { Schedule } from './state'
import { TOKEN_PROGRAM_ID } from '@solana/spl-token'

export async function findAssociatedTokenAddress(
  walletAddress: PublicKey,
  tokenMintAddress: PublicKey
): Promise<PublicKey> {
  return (
    await PublicKey.findProgramAddress(
      [walletAddress.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), tokenMintAddress.toBuffer()],
      ASSOCIATED_TOKEN_PROGRAM_ID
    )
  )[0]
}

export class Numberu64 extends BN {
  /**
   * Convert to Buffer representation
   */
  toBuffer(): Buffer {
    const a = super.toArray().reverse()
    const b = Buffer.from(a)
    if (b.length === 8) {
      return b
    }
    assert(b.length < 8, 'Numberu64 too large')

    const zeroPad = Buffer.alloc(8)
    b.copy(zeroPad)
    return zeroPad
  }

  /**
   * Construct a Numberu64 from Buffer representation
   */
  static fromBuffer(buffer): any {
    assert(buffer.length === 8, `Invalid buffer length: ${buffer.length}`)
    return new BN(
      [...buffer]
        .reverse()
        .map((i) => `00${i.toString(16)}`.slice(-2))
        .join(''),
      16
    )
  }
}

export class Numberu32 extends BN {
  /**
   * Convert to Buffer representation
   */
  toBuffer(): Buffer {
    const a = super.toArray().reverse()
    const b = Buffer.from(a)
    if (b.length === 4) {
      return b
    }
    assert(b.length < 4, 'Numberu32 too large')

    const zeroPad = Buffer.alloc(4)
    b.copy(zeroPad)
    return zeroPad
  }

  /**
   * Construct a Numberu32 from Buffer representation
   */
  static fromBuffer(buffer): any {
    assert(buffer.length === 4, `Invalid buffer length: ${buffer.length}`)
    return new BN(
      [...buffer]
        .reverse()
        .map((i) => `00${i.toString(16)}`.slice(-2))
        .join(''),
      16
    )
  }
}

// Connection

const ENDPOINTS = {
  mainnet: 'https://solana-api.projectserum.com',
  devnet: 'https://devnet.solana.com'
}

export const connection = new Connection(ENDPOINTS.devnet)

// For accounts imported from Sollet.io

export const getDerivedSeed = (seed: Buffer): Uint8Array => {
  const derivedSeed = bip32.fromSeed(seed).derivePath(`m/501'/0'/0/0`).privateKey
  return nacl.sign.keyPair.fromSeed(derivedSeed as any).secretKey
}

export const getAccountFromSeed = (seed: Buffer): Account => {
  const derivedSeed = bip32.fromSeed(seed).derivePath(`m/501'/0'/0/0`).privateKey
  return new Account(nacl.sign.keyPair.fromSeed(derivedSeed as any).secretKey)
}

export const ASSOCIATED_TOKEN_PROGRAM_ID: PublicKey = new PublicKey(
  'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'
)
export const generateRandomSeed = () => {
  // Generate a random seed
  let seed = ''
  for (let i = 0; i < 64; i++) {
    seed += Math.floor(Math.random() * 10)
  }
  return seed
}

export const sleep = (ms: number): Promise<void> => {
  return new Promise((resolve) => setTimeout(resolve, ms))
}

// Sign transaction

export const signTransactionInstructions = async (
  // sign and send transaction
  connection: Connection,
  signers: Array<Account>,
  feePayer: PublicKey,
  txInstructions: Array<TransactionInstruction>
): Promise<string> => {
  const tx = new Transaction()
  tx.feePayer = feePayer
  tx.add(...txInstructions)
  return await connection.sendTransaction(tx, signers, {
    preflightCommitment: 'single'
  })
}

export const createAssociatedTokenAccount = async (
  systemProgramId: PublicKey,
  clockSysvarId: PublicKey,
  fundingAddress: PublicKey,
  walletAddress: PublicKey,
  splTokenMintAddress: PublicKey
): Promise<TransactionInstruction> => {
  const associatedTokenAddress = await findAssociatedTokenAddress(
    walletAddress,
    splTokenMintAddress
  )
  const keys = [
    {
      pubkey: fundingAddress,
      isSigner: true,
      isWritable: true
    },
    {
      pubkey: associatedTokenAddress,
      isSigner: false,
      isWritable: true
    },
    {
      pubkey: walletAddress,
      isSigner: false,
      isWritable: false
    },
    {
      pubkey: splTokenMintAddress,
      isSigner: false,
      isWritable: false
    },
    {
      pubkey: systemProgramId,
      isSigner: false,
      isWritable: false
    },
    {
      pubkey: TOKEN_PROGRAM_ID,
      isSigner: false,
      isWritable: false
    },
    {
      pubkey: SYSVAR_RENT_PUBKEY,
      isSigner: false,
      isWritable: false
    }
  ]
  return new TransactionInstruction({
    keys,
    programId: ASSOCIATED_TOKEN_PROGRAM_ID,
    data: Buffer.from([])
  })
}
